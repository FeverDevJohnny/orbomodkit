# Working With JSwitch

[(API Reference for JSwitch)](https://github.com/FeverDevJohnny/orbomodkit/tree/main/Docs/8.%20JSwitch/API%20Reference)

While a JTrigger is essentially an if()else{} statement, a JSwitch is... Well, a switch statement.

The main difference is that JSwitches have a priority system, because unlike a switch statement multiple individual branches of a JSwitch can be true at once.

Anyhow, we'll briefly discuss the settings for a JSwitch and then we can talk about actually using one.

The **Branches** setting is the actual array of conditionals you'll define. A branch element has three settings:

- **Conditions** - These are the same as JTrigger conditions, and when they're all met this branch is considered valid for operation.
- **Priority** - This is important: Since multiple branches can be true at once, the priority defines which one is more important, and therefor, the one that should be ran once we're done analyzing the branches.
- **Events** - This is a JTrigger, configured as On Demand, that the JSwitch will run if it both its conditions are met and it's priority is the highest among all valid branches.

The **Default Event** setting is an optional event you can provide that will be ran if none of the branches return as true. If you're using a JSwitch to handle dialog progression for an NPC, this can be used to link into an intro conversation.

To actually run a JSwitch, a JTrigger or JComposer must call **JSwitch > Operate()**, which will cause the JSwitch to analyze its branches and subsequently run the winning branch's event as On Demand.

---

## Caveats, Miscellaneous Info and Known Issues

Believe it or not: Unity doesn't do a great job supporting most of their features, and I'm also prone to mistakes! So there are some technical issues with mods that I would like to address here.

---

### Lightmapping

Orbo mods support using lightmaps on your models. You can even use light probes!

However, **you must use Non-Directional lightmaps**. Directional lightmaps do not work with the shader variants generated by the scriptable compatibility build pipeline, so your lightmapped objects will break if you do it this way.

---

### Complexity

I tried to integrate a decent chunk of universalized systems so you could try and add fun set pieces that didn't show up in the original game, but I want to acknowledge now that this toolset isn't going to give you everything you could ask for. I made it as a way of saying thanks for the people who bought the game and were kind to me while I was in a very bad place.

Think of this modding toolkit like Nintendo's _Super Mario Maker_. You can get creative with the tools to create levels that feature really intriguing mechanics not present in the base game, but at the end of the day the toolset is just there for you to make fun levels.

The game wasn't built around the idea that it would receive mods, so keep in mind that this modding toolkit is scaffolded around the base game in a way that might make some things feel clunky or strange. I tried to simplify the process where I could, but that's about all I could do. I still have to get to work on my main game lol.

---

### On Trigger Passthrough and Duplicate Events

This is a really helpful system, but keep in mind that if your passthrough's trigger volume overlaps with its source object's trigger volume, it can generate duplicate OnTriggerEnter and OnTriggerExit events on your target object. This might be fine if you're dealing with modkit objects that have one-shot behavior (key orbs, for example, only get collected on the first trigger event and will ignore duplicates), but with JTriggers and Interactables this could cause some unexpected behavior. In these two explicit cases, **try to make sure you're only using passthroughs when there is absolutely no way to have the player make contact with your target object's trigger collider**.

I haven't devised a way to deal with this yet that I feel satisfied with, so maybe at somepoint down the road I'll rework how passthroughs behave with triggerable objects to make it a bit more friendly. For now, just accept that this is a known issue and try to be careful not to walk into a trap.

---

### Tags and Layers

You cannot define new tags and layers for your modded levels due to a technical constraint with how Unity handles asset bundles and these types of data.
I have tried to supply some options to make things easier, and I will list and explain all of the tags and layers here:

**Tags**

- **KeyOrb_Blue** - Used on blue key orbs to transmit data to slab doors. Strongly recommend you avoid using this for your own objects as it might confuse the doors and cause errors.
- **KeyOrb_Pink** - Used on pink key orbs to transmit data to slab doors. Strongly recommend you avoid using this for your own objects as it might confuse the doors and cause errors.
- **KeyOrb_Green** - Used on green key orbs to transmit data to slab doors. Strongly recommend you avoid using this for your own objects as it might confuse the doors and cause errors.
- **KeyOrb_Red** - Used on red key orbs to transmit data to slab doors. Strongly recommend you avoid using this for your own objects as it might confuse the doors and cause errors.
- **IgnoreTracking** - Tells the composer system that Orbo's body shouldn't try to look at this associated object if it's marked as the camera's current view target.
- **GnomeHead** - Internal ID used in the main game for the gnome quest. You can use this if you want, there's no scripts in the modding system to conflict with this.
- **NukeBall** - Internal ID for the boss's aerial mine attack. Also used in the gnome quest.
- **CrazyShapeGate** - Internal ID for the crazy shape gate in the monolith station puzzle.
- **Tag_A** - A pre-reserved tag you can use for your modded objects!
- **Tag_B** - A pre-reserved tag you can use for your modded objects!
- **Tag_C** - A pre-reserved tag you can use for your modded objects!
- **Tag_D** - A pre-reserved tag you can use for your modded objects!
- **Tag_E** - A pre-reserved tag you can use for your modded objects!
- **Tag_F** - A pre-reserved tag you can use for your modded objects!
- **Tag_G** - A pre-reserved tag you can use for your modded objects!
- **Tag_H** - A pre-reserved tag you can use for your modded objects!
- **Tag_I** - A pre-reserved tag you can use for your modded objects!

**Layers**

- **Player** - This is the contact layer for the player. I recommend not using this one or else you might encounter some technical issues.
- **UIPrerender** - This was used back when the game had 3D UI elements, but has since become deprecated. This can be ignored.
- **PlayerNoCollide** - Useful! This tells an object to avoid collding with the player. You can use this to create objects that can interact with triggers without interfering with the player.
- **Gib** - Used internally for breakable sand walls and other destructive remnants. Won't collide with the player.
- **Damageable** - Marks an object for use in the aim-assist feature (causes Orbo to curve towards the object while drilling). Players will slide off of these objects if they land on them.
- **Damageable_WalkOn** - Same as Damageable, but the player won't slide while walking on them. Typically used for gust plates and the like.
- **PlayerBlocker** - This makes it so an object will collide with the player, but the camera won't. Quite useful for decorative elements in a scene.
- **BlockerPassthrough** - This object won't colide with player blockers, but will collide with everything else. Used on Peeb during the hallway cutscene so he can head into the light while Orbo can't.
- **NoWallslide** - The player and the camera will collide with this object, but the player cannot wallslide on it. Used in a few places in-game, like the hall leading out of the boss's office that Orbo cannot access without fighting the HR Rep first.

---
